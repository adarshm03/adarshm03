<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>ADARSH — Zoro Haki Edition</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
body{
  background:#000;
  display:flex;justify-content:center;align-items:center;
  min-height:100vh;overflow:hidden;
}
.wrap{
  position:relative;
  width:1000px;height:340px;
  background:#000;overflow:hidden;
}
canvas{position:absolute;top:0;left:0;width:100%;height:100%;}

/* SCANLINES */
.scan{
  position:absolute;top:0;left:0;width:100%;height:100%;z-index:30;pointer-events:none;
  background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.09) 2px,rgba(0,0,0,0.09) 4px);
}
/* VIGNETTE */
.vig{
  position:absolute;top:0;left:0;width:100%;height:100%;z-index:25;pointer-events:none;
  background:radial-gradient(ellipse at 50% 50%,transparent 30%,rgba(0,0,0,0.88) 100%);
}
/* LETTERBOX */
.bar-top,.bar-bot{
  position:absolute;left:0;width:100%;height:26px;
  background:#000;z-index:28;
}
.bar-top{top:0;}.bar-bot{bottom:0;}

/* TEXT LAYER */
#textWrap{
  position:absolute;top:0;left:0;width:100%;height:100%;
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  z-index:20;pointer-events:none;
}
#mainTitle{
  font-family:'Black Han Sans','Impact','Arial Black',sans-serif;
  font-size:108px;
  letter-spacing:16px;
  color:#00FF44;
  -webkit-text-stroke:2px #001a0a;
  text-shadow:
    0 0 8px #00FF44,
    0 0 28px #00CC33,
    0 0 65px rgba(0,255,68,0.5),
    5px 5px 0 #001408;
  opacity:0;
  transform:scale(2.8) skewX(-22deg);
  filter:blur(24px);
  will-change:transform,opacity,filter;
  transition: text-shadow 0.4s;
}
#mainTitle.on{
  animation:slamIn 0.55s cubic-bezier(0.05,1.15,0.15,1) forwards;
}
/* Purple haki pulse on text — added by JS class */
#mainTitle.haki-pulse{
  text-shadow:
    0 0 8px #00FF44,
    0 0 28px #00CC33,
    0 0 65px rgba(0,255,68,0.55),
    5px 5px 0 #001408,
    0 0 120px rgba(120,0,255,0.45),
    0 0 200px rgba(80,0,180,0.25);
}

#sub{
  font-family:'Black Han Sans',monospace;
  font-size:14px;
  letter-spacing:9px;
  color:#00FF44;
  text-shadow:0 0 12px #00FF44,0 0 28px #006622;
  opacity:0;margin-top:6px;
  transform:translateY(22px);
  transition:opacity .6s 1.1s,transform .6s 1.1s;
}
#sub.on{opacity:.9;transform:translateY(0);}

@keyframes slamIn{
  0%  {opacity:0;transform:scale(2.8) skewX(-22deg);filter:blur(24px);}
  45% {opacity:1;transform:scale(0.93) skewX(3deg);filter:blur(0);}
  68% {transform:scale(1.04) skewX(-1deg);}
  100%{opacity:1;transform:scale(1) skewX(0);filter:blur(0);}
}

/* SHAKE */
.shake{animation:shk .07s infinite;}
@keyframes shk{
  0%  {transform:translate(5px,3px) rotate(.6deg);}
  25% {transform:translate(-5px,-4px) rotate(-1deg);}
  50% {transform:translate(6px,4px) rotate(1deg);}
  75% {transform:translate(-4px,5px) rotate(-.5deg);}
  100%{transform:translate(3px,-3px) rotate(0);}
}
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <canvas id="c"></canvas>
  <div class="vig"></div>
  <div class="scan"></div>
  <div class="bar-top"></div>
  <div class="bar-bot"></div>
  <div id="textWrap">
    <div id="mainTitle" id="mainTitle">ADARSH</div>
    <div id="sub">Code &nbsp;&#9670;&nbsp; Linux &nbsp;&#9670;&nbsp; Learning</div>
  </div>
</div>

<script>
// ════════════════════════════════════════════════════════
//  SETUP
// ════════════════════════════════════════════════════════
const wrap = document.getElementById('wrap');
const c    = document.getElementById('c');
const ctx  = c.getContext('2d');
const W=1000, H=340;
c.width=W; c.height=H;

const titleEl = document.getElementById('mainTitle');
const subEl   = document.getElementById('sub');

// ════════════════════════════════════════════════════════
//  Z-PATH  (true letter-Z: top-horiz → diagonal → bot-horiz)
// ════════════════════════════════════════════════════════
const Z = [
  {x:60,  y:100},   // A top-left
  {x:940, y:100},   // B top-right
  {x:60,  y:255},   // C bot-left
  {x:940, y:255}    // D bot-right
];
const SEGS = [[Z[0],Z[1]],[Z[1],Z[2]],[Z[2],Z[3]]];
const LENS = SEGS.map(([a,b])=>Math.hypot(b.x-a.x,b.y-a.y));
const CUM  = [0,LENS[0],LENS[0]+LENS[1],LENS[0]+LENS[1]+LENS[2]];
const TOTAL = CUM[3];

function posOnZ(d){
  d=Math.max(0,Math.min(d,TOTAL));
  for(let i=0;i<SEGS.length;i++){
    if(d<=CUM[i+1]){
      const t=(d-CUM[i])/LENS[i];
      const [a,b]=SEGS[i];
      return{x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t,
             angle:Math.atan2(b.y-a.y,b.x-a.x)};
    }
  }
  return{...Z[3],angle:0};
}

// Sample Z-path points for haki origin anchors later
const ZANCHORS=[];
for(let d=0;d<=TOTAL;d+=60) ZANCHORS.push(posOnZ(d));

// ════════════════════════════════════════════════════════
//  PARTICLE POOLS
// ════════════════════════════════════════════════════════
let sparks   = [];
let embers   = [];
let rings    = [];
let hakiPtcl = [];          // green haki dots (charge phase)
let purpleStorms = [];      // ★ One-Piece purple haki lightning events

// ════════════════════════════════════════════════════════
//  SPARKS (welding-spark style — matches reference image)
// ════════════════════════════════════════════════════════
function spawnSparks(x,y,ang,n){
  for(let i=0;i<n;i++){
    const side=(Math.random()>.5)?1:-1;
    const spread=(Math.random()-.5)*Math.PI*.9;
    const a=(ang+Math.PI/2)*side+ang+Math.PI*.6+spread;
    const spd=Math.random()*18+4;
    const life=Math.random()*28+10;
    const w=Math.random();
    sparks.push({x,y,
      vx:Math.cos(a)*spd, vy:Math.sin(a)*spd,
      life,maxLife:life,
      color:w<.25?'#FFFFFF':w<.55?'#FFEEAA':w<.8?'#FF8800':'#CC3300',
      r:Math.random()*1.8+.4});
  }
}
function spawnEmbers(x,y,n){
  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2;
    embers.push({
      x:x+(Math.random()-.5)*30, y:y+(Math.random()-.5)*30,
      vx:Math.cos(a)*(Math.random()*1.5+.3),
      vy:Math.sin(a)*(Math.random()*1.5+.3),
      life:Math.random()*80+40, maxLife:120,
      color:'#FF5500', r:Math.random()*1.2+.3});
  }
}
function spawnRing(cx,cy,maxR,col){
  rings.push({x:cx,y:cy,r:5,maxR,life:28,maxLife:28,col:col||'#00FF44'});
}

// ════════════════════════════════════════════════════════
//  ★ PURPLE HAKI LIGHTNING SYSTEM — One Piece accurate
//  Conqueror's / Armament haki = dark black-purple
//  crackling electric storm, random branching bolts
// ════════════════════════════════════════════════════════

// Recursively generate a jagged lightning path array
function genLightning(x1,y1,x2,y2,depth,jitter){
  if(depth===0||Math.hypot(x2-x1,y2-y1)<6)
    return [{x:x1,y:y1},{x:x2,y:y2}];
  const len=Math.hypot(x2-x1,y2-y1);
  const j=jitter===undefined?len*.5:jitter;
  // Perpendicular displacement
  const nx=-(y2-y1)/len, ny=(x2-x1)/len;
  const disp=(Math.random()-.5)*j;
  const mx=(x1+x2)/2+nx*disp;
  const my=(y1+y2)/2+ny*disp;
  return [
    ...genLightning(x1,y1,mx,my,depth-1,j*.5),
    ...genLightning(mx,my,x2,y2,depth-1,j*.5).slice(1)
  ];
}

// Draw a pre-generated path as a multi-layer haki bolt
function drawHakiBolt(pts,alpha,thick){
  if(!pts||pts.length<2)return;
  ctx.save();
  ctx.lineCap='round';ctx.lineJoin='round';

  // Outer dark purple haze
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  pts.forEach(p=>ctx.lineTo(p.x,p.y));
  ctx.strokeStyle='rgba(40,0,80,0.6)';
  ctx.lineWidth=thick*5;
  ctx.shadowBlur=30; ctx.shadowColor='#330066';
  ctx.globalAlpha=alpha*.6;
  ctx.stroke();

  // Mid purple glow
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  pts.forEach(p=>ctx.lineTo(p.x,p.y));
  ctx.strokeStyle='#6600CC';
  ctx.lineWidth=thick*2.2;
  ctx.shadowBlur=18; ctx.shadowColor='#9933FF';
  ctx.globalAlpha=alpha*.85;
  ctx.stroke();

  // Bright purple core
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  pts.forEach(p=>ctx.lineTo(p.x,p.y));
  ctx.strokeStyle='#CC88FF';
  ctx.lineWidth=thick*.7;
  ctx.shadowBlur=8; ctx.shadowColor='#FF99FF';
  ctx.globalAlpha=alpha;
  ctx.stroke();

  // White-hot tip flicker
  ctx.beginPath();
  ctx.moveTo(pts[0].x,pts[0].y);
  pts.forEach(p=>ctx.lineTo(p.x,p.y));
  ctx.strokeStyle='#FFFFFF';
  ctx.lineWidth=thick*.25;
  ctx.shadowBlur=2;
  ctx.globalAlpha=alpha*.7;
  ctx.stroke();

  ctx.restore();
}

// Spawn a haki storm event: a main bolt + 0-3 branches
// Origin: from around the text/slash, random destination in screen
function spawnHakiStorm(intensity){
  // Origin: biased toward text centre & slash anchors
  let ox,oy;
  const src=Math.random();
  if(src<.5){
    // From text centre region
    ox=W/2+(Math.random()-.5)*260;
    oy=H/2+(Math.random()-.5)*80;
  } else if(src<.75 && ZANCHORS.length){
    // From a slash mark
    const anch=ZANCHORS[Math.floor(Math.random()*ZANCHORS.length)];
    ox=anch.x+(Math.random()-.5)*30;
    oy=anch.y+(Math.random()-.5)*20;
  } else {
    // From random screen edge neighbourhood
    ox=Math.random()*W;
    oy=Math.random()*H;
  }

  // How many main bolts in this burst
  const numBolts=Math.random()<.2 ? Math.floor(Math.random()*3+3) : Math.floor(Math.random()*2+1);

  for(let b=0;b<numBolts;b++){
    // Destination: random, tends to go outward from origin
    const angle=Math.random()*Math.PI*2;
    const len=Math.random()*180+60+(intensity||0)*80;
    const tx=ox+Math.cos(angle)*len;
    const ty=oy+Math.sin(angle)*len;

    const depth=Math.floor(Math.random()*2+3); // 3-4 levels
    const mainPts=genLightning(ox,oy,tx,ty,depth);
    const life=Math.floor(Math.random()*5+3);  // 3-8 frames
    const thick=Math.random()*1.5+.8;

    purpleStorms.push({pts:mainPts, life, maxLife:life, thick, branch:[]});

    // Random branches off the main bolt
    const numBranches=Math.floor(Math.random()*3);
    for(let br=0;br<numBranches;br++){
      const bSrc=mainPts[Math.floor(Math.random()*(mainPts.length-1))];
      const bAngle=angle+(Math.random()-.5)*1.4;
      const bLen=len*(Math.random()*.4+.15);
      const bx=bSrc.x+Math.cos(bAngle)*bLen;
      const by=bSrc.y+Math.sin(bAngle)*bLen;
      const bPts=genLightning(bSrc.x,bSrc.y,bx,by,Math.max(1,depth-2));
      purpleStorms[purpleStorms.length-1].branch.push(bPts);
    }
  }
}

// Randomly decide each frame whether to fire a storm
// - nextStormIn: countdown frames until next storm event
let nextStormIn=5;
let stormIntensity=1; // 0-1, high right after slash then slowly random

function tickHakiStorms(){
  nextStormIn--;
  if(nextStormIn<=0){
    // Fire burst
    const burstSize=Math.random()<.15 ? Math.floor(Math.random()*4+4) : Math.floor(Math.random()*2+1);
    for(let i=0;i<burstSize;i++) spawnHakiStorm(stormIntensity*.5+Math.random()*.5);
    // Next storm: random gap — sometimes very quick, sometimes a long pause
    if(Math.random()<.12){
      // Dramatic pause then mega burst
      nextStormIn=Math.floor(Math.random()*40+20);
    } else {
      nextStormIn=Math.floor(Math.random()*12+2);
    }
    stormIntensity=Math.max(.2, stormIntensity-.01);
  }
}

function renderHakiStorms(){
  purpleStorms=purpleStorms.filter(s=>s.life>0);
  purpleStorms.forEach(s=>{
    const a=s.life/s.maxLife;
    s.life--;
    drawHakiBolt(s.pts, a, s.thick);
    s.branch.forEach(b=>drawHakiBolt(b, a*.6, s.thick*.55));
  });
}

// Purple ambient haze (the atmospheric dark-purple energy cloud)
function drawPurpleHaze(postFrame){
  const pulse=Math.sin(postFrame*.08)*.5+.5;
  const pulse2=Math.cos(postFrame*.13)*.5+.5;
  ctx.save();
  // Wide purple cloud around text
  const g=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,300);
  g.addColorStop(0, `rgba(50,0,100,${.06+pulse*.06})`);
  g.addColorStop(.4, `rgba(30,0,60,${.04+pulse2*.04})`);
  g.addColorStop(1, 'transparent');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,W,H);

  // Narrow haze along Z-slash scars
  ctx.globalAlpha=.18+pulse*.12;
  ZANCHORS.forEach((anch,i)=>{
    if(i%4!==0)return;
    const sg=ctx.createRadialGradient(anch.x,anch.y,0,anch.x,anch.y,18);
    sg.addColorStop(0,'rgba(100,0,200,.6)');
    sg.addColorStop(1,'transparent');
    ctx.fillStyle=sg;
    ctx.beginPath();ctx.arc(anch.x,anch.y,18,0,Math.PI*2);ctx.fill();
  });
  ctx.restore();
}

// Toggle text haki-pulse class periodically
let textHakiOn=false;
function tickTextHaki(postFrame){
  // Randomly strobe the purple text glow
  if(Math.random()<.06){
    textHakiOn=!textHakiOn;
    if(textHakiOn) titleEl.classList.add('haki-pulse');
    else           titleEl.classList.remove('haki-pulse');
  }
}

// ════════════════════════════════════════════════════════
//  SLASH DRAW  (matches reference photo: red-orange-white)
// ════════════════════════════════════════════════════════
let trail=[];
function drawSlash(pts,alpha){
  if(pts.length<2)return;
  ctx.save();
  ctx.lineCap='round';ctx.lineJoin='round';

  const draw=(lw,col,blur,a)=>{
    ctx.beginPath();
    ctx.moveTo(pts[0].x,pts[0].y);
    pts.forEach(p=>ctx.lineTo(p.x,p.y));
    ctx.strokeStyle=col; ctx.lineWidth=lw;
    ctx.shadowBlur=blur; ctx.shadowColor=col;
    ctx.globalAlpha=a!==undefined?a:alpha;
    ctx.stroke();
  };
  draw(22,'#550000',40,alpha*.55);
  draw(12,'#CC2200',25,alpha*.8);
  draw(5,'#FF7700',15,alpha);
  draw(2.5,'#FFEE88',10,alpha);
  draw(1.2,'#FFFFFF',4,alpha);
  ctx.restore();
}

// ════════════════════════════════════════════════════════
//  LENS-FLARE TIP
// ════════════════════════════════════════════════════════
function drawTip(x,y){
  ctx.save(); ctx.translate(x,y);
  const g1=ctx.createLinearGradient(-200,0,200,0);
  g1.addColorStop(0,'transparent');
  g1.addColorStop(.35,'rgba(255,180,60,.3)');
  g1.addColorStop(.5,'rgba(255,255,255,1)');
  g1.addColorStop(.65,'rgba(255,180,60,.3)');
  g1.addColorStop(1,'transparent');
  ctx.fillStyle=g1;
  ctx.beginPath(); ctx.ellipse(0,0,200,2.5,0,0,Math.PI*2); ctx.fill();
  const g2=ctx.createLinearGradient(0,-80,0,80);
  g2.addColorStop(0,'transparent');
  g2.addColorStop(.5,'rgba(255,255,255,.7)');
  g2.addColorStop(1,'transparent');
  ctx.fillStyle=g2;
  ctx.beginPath(); ctx.ellipse(0,0,1.5,80,0,0,Math.PI*2); ctx.fill();
  const gc=ctx.createRadialGradient(0,0,0,0,0,20);
  gc.addColorStop(0,'#FFFFFF');
  gc.addColorStop(.3,'#FFEEAA');
  gc.addColorStop(.7,'rgba(255,120,0,.4)');
  gc.addColorStop(1,'transparent');
  ctx.fillStyle=gc;
  ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

// ════════════════════════════════════════════════════════
//  ZORO STICKMAN
// ════════════════════════════════════════════════════════
function drawZoro(cx,cy,stance,haki){
  ctx.save(); ctx.translate(cx,cy);
  const h=Math.min(1,haki);

  if(h>.1){
    const ag=ctx.createRadialGradient(0,30,0,0,30,80+h*40);
    ag.addColorStop(0,`rgba(0,10,3,${h*.95})`);
    ag.addColorStop(.6,`rgba(0,50,15,${h*.4})`);
    ag.addColorStop(1,'transparent');
    ctx.fillStyle=ag;
    ctx.beginPath(); ctx.ellipse(0,30,80+h*40,55+h*20,0,0,Math.PI*2); ctx.fill();
  }

  const bc=h>.65?`rgb(${Math.floor(h*8)},${Math.floor(h*60+10)},${Math.floor(h*20)})`:'#E0E0E0';
  ctx.strokeStyle=bc; ctx.lineWidth=4; ctx.lineCap='round'; ctx.lineJoin='round';
  if(h>.3){ctx.shadowBlur=14*h; ctx.shadowColor='#00FF44';}

  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,44); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,44); ctx.lineTo(-26,88); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,44); ctx.lineTo(26,88); ctx.stroke();
  ctx.beginPath(); ctx.arc(0,-16,14,0,Math.PI*2); ctx.stroke();
  ctx.fillStyle=h>.55?'#001800':'#006622';
  ctx.shadowBlur=6; ctx.shadowColor='#00FF44';
  ctx.fillRect(-14,-27,28,9);
  ctx.fillStyle='#00FF44'; ctx.shadowBlur=18; ctx.shadowColor='#00FF44';
  ctx.beginPath(); ctx.arc(-3,-22,3,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;
  ctx.strokeStyle=h>.5?'#001800':'#BBBBBB'; ctx.lineWidth=3.5;
  ctx.shadowBlur=h>.5?10:0; ctx.shadowColor='#00FF44';
  ctx.beginPath(); ctx.moveTo(-28,-11); ctx.lineTo(38,-11); ctx.stroke();
  ctx.shadowBlur=0;

  if(stance==='charge'){
    ctx.strokeStyle='#DDDDDD'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,5); ctx.lineTo(-22,20); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,8); ctx.lineTo(22,22); ctx.stroke();
    ctx.strokeStyle=h>.5?'#001800':'#CCCCCC'; ctx.lineWidth=3.5;
    ctx.shadowBlur=h>.3?14:0; ctx.shadowColor='#00FF44';
    ctx.beginPath(); ctx.moveTo(-22,20); ctx.lineTo(32,-60); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(22,22); ctx.lineTo(-32,-55); ctx.stroke();
  } else {
    ctx.strokeStyle='#DDDDDD'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(0,5); ctx.lineTo(-36,10); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(36,14); ctx.stroke();
    ctx.strokeStyle=h>.5?'#001000':'#BBBBBB'; ctx.lineWidth=4.5;
    ctx.shadowBlur=22; ctx.shadowColor='#00FF44';
    ctx.beginPath(); ctx.moveTo(-36,10); ctx.lineTo(-115,-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(36,14); ctx.lineTo(115,8); ctx.stroke();
    ctx.strokeStyle='#00FF44'; ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.moveTo(-36,10); ctx.lineTo(-115,-2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(36,14); ctx.lineTo(115,8); ctx.stroke();
  }
  ctx.restore();
}

// ════════════════════════════════════════════════════════
//  STATE
// ════════════════════════════════════════════════════════
const MX=W/2, MY=H/2-20;
let phase='charge';
let frame=0, postFrame=0;
let hakiLevel=0;
let slashDist=0;
let shakeFrames=0;
let flashAlpha=0;
let trailAlpha=1;
const SPEED=22;

// ════════════════════════════════════════════════════════
//  RENDER LOOP
// ════════════════════════════════════════════════════════
function render(){
  requestAnimationFrame(render);
  frame++;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  if(shakeFrames>0){wrap.classList.add('shake');shakeFrames--;}
  else wrap.classList.remove('shake');

  // ─── CHARGE ──────────────────────────────────────────
  if(phase==='charge'){
    hakiLevel=Math.min(1,frame/110);

    if(frame%2===0){
      const a=Math.random()*Math.PI*2, r=Math.random()*130+50;
      sparks.push({x:MX+Math.cos(a)*r, y:MY+Math.sin(a)*r,
        vx:-Math.cos(a)*(1.5+hakiLevel*3), vy:-Math.sin(a)*(1.5+hakiLevel*3),
        life:20,maxLife:20,
        color:hakiLevel>.6?'#001800':'#00AA44', r:1.2+hakiLevel*1.5});
    }
    if(frame>40&&frame%22===0) spawnRing(MX,MY-10,90+hakiLevel*60,'#00FF44');
    if(frame>55&&frame%9===0){
      for(let i=0;i<7;i++){
        const a=Math.random()*Math.PI*2;
        sparks.push({x:MX,y:MY-10,
          vx:Math.cos(a)*2,vy:Math.sin(a)*2,
          life:8,maxLife:8,
          color:i%3===0?'#00FF44':'#001a08',r:1});
      }
    }
    drawZoro(MX,MY,'charge',hakiLevel);
    if(frame>140){phase='flash';frame=0;shakeFrames=10;flashAlpha=2;}
  }

  // ─── FLASH ───────────────────────────────────────────
  if(phase==='flash'){
    drawZoro(MX,MY,'slash',1);
    flashAlpha-=.18;
    if(flashAlpha>0){
      ctx.save(); ctx.globalAlpha=Math.min(1,flashAlpha);
      ctx.fillStyle=frame%2===0?'#FFFFFF':'rgba(0,255,68,0.5)';
      ctx.fillRect(0,0,W,H); ctx.restore();
    }
    if(frame>10){
      phase='slash';frame=0;
      spawnRing(MX,MY,250,'#00FF44');
      shakeFrames=50;
    }
  }

  // ─── SLASH ───────────────────────────────────────────
  if(phase==='slash'){
    slashDist+=SPEED;
    const pos=posOnZ(slashDist);
    trail.push({x:pos.x,y:pos.y});
    spawnSparks(pos.x,pos.y,pos.angle,18);
    if(frame%3===0) spawnEmbers(pos.x,pos.y,5);
    drawSlash(trail,1);
    drawTip(pos.x,pos.y);
    drawZoro(MX,MY,'slash',0.7);
    shakeFrames=3;
    if(slashDist>=TOTAL){
      phase='done';frame=0;
      shakeFrames=20;
      spawnRing(W/2,H/2,320,'#00FF44');
      spawnRing(W/2,H/2,240,'#00FF44');
      flashAlpha=1.3;
      // Initial mega haki burst on completion
      stormIntensity=1.5;
      nextStormIn=1;
      for(let i=0;i<6;i++) spawnHakiStorm(1);
    }
  }

  // ─── DONE ─────────────────────────────────────────────
  if(phase==='done'){
    postFrame++;

    // Slash trail fading with purple haze overlay
    trailAlpha=Math.max(.04,1-postFrame/55);
    if(trail.length>1) drawSlash(trail,trailAlpha);

    // White flash
    if(flashAlpha>0){
      ctx.save(); ctx.globalAlpha=Math.min(1,flashAlpha);
      ctx.fillStyle='#FFFFFF'; ctx.fillRect(0,0,W,H);
      ctx.restore();
      flashAlpha-=.08;
    }

    // Text reveal
    if(postFrame===4){
      titleEl.classList.add('on');
      subEl.classList.add('on');
    }

    // Purple haki storm system
    if(postFrame>8){
      drawPurpleHaze(postFrame);
      tickHakiStorms();
      renderHakiStorms();
      tickTextHaki(postFrame);
    }

    // ── 3 SECOND HOLD (≈180 frames) then fade-to-black and loop ──
    const HOLD_FRAMES = 360; // ~6s at 60fps — text stays clearly visible for 3+ sec
    const FADE_FRAMES = 50;  // ~0.8s fade

    if(postFrame > HOLD_FRAMES){
      const fadeProgress = (postFrame - HOLD_FRAMES) / FADE_FRAMES;
      const fadeAlpha = Math.min(1, fadeProgress);
      ctx.save();
      ctx.globalAlpha = fadeAlpha;
      ctx.fillStyle   = '#000000';
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      // Also fade the text out via opacity on the element
      const textAlpha = Math.max(0, 1 - fadeAlpha);
      titleEl.style.opacity = textAlpha;
      subEl.style.opacity   = textAlpha * 0.9;

      if(postFrame >= HOLD_FRAMES + FADE_FRAMES) {
        resetAll();
      }
    }
  }

  // ─── PARTICLES ───────────────────────────────────────
  sparks=sparks.filter(s=>s.life>0);
  ctx.save();
  sparks.forEach(s=>{
    s.x+=s.vx; s.y+=s.vy;
    s.vx*=.91; s.vy*=.91;
    s.vy+=.25;
    s.life--;
    const a=s.life/s.maxLife;
    const spd=Math.hypot(s.vx,s.vy);
    const ang=Math.atan2(s.vy,s.vx);
    ctx.globalAlpha=a; ctx.fillStyle=s.color;
    ctx.shadowBlur=8; ctx.shadowColor=s.color;
    ctx.translate(s.x,s.y); ctx.rotate(ang);
    ctx.beginPath(); ctx.ellipse(0,0,Math.max(s.r,spd*.55),s.r*.5,0,0,Math.PI*2); ctx.fill();
    ctx.rotate(-ang); ctx.translate(-s.x,-s.y);
  });
  ctx.restore();

  embers=embers.filter(e=>e.life>0);
  ctx.save();
  embers.forEach(e=>{
    e.x+=e.vx; e.y+=e.vy; e.vy+=.04; e.life--;
    ctx.globalAlpha=(e.life/e.maxLife)*.8;
    ctx.fillStyle=e.color; ctx.shadowBlur=5; ctx.shadowColor='#FF5500';
    ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
  });
  ctx.restore();

  rings=rings.filter(r=>r.life>0);
  ctx.save();
  rings.forEach(r=>{
    r.r+=(r.maxR-r.r)*.13; r.life--;
    const a=r.life/r.maxLife;
    ctx.globalAlpha=a; ctx.strokeStyle=r.col||'#00FF44';
    ctx.lineWidth=2; ctx.shadowBlur=14; ctx.shadowColor=r.col||'#00FF44';
    ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.stroke();
  });
  ctx.restore();
}

// ════════════════════════════════════════════════════════
//  RESET — wipe all state and restart the cycle
// ════════════════════════════════════════════════════════
function resetAll(){
  sparks=[];embers=[];rings=[];hakiPtcl=[];purpleStorms=[];trail=[];
  phase='charge';frame=0;postFrame=0;hakiLevel=0;slashDist=0;
  shakeFrames=0;flashAlpha=0;trailAlpha=1;
  stormIntensity=1;nextStormIn=5;textHakiOn=false;
  // Remove classes so CSS animation can re-fire cleanly
  titleEl.classList.remove('on','haki-pulse');
  subEl.classList.remove('on');
  titleEl.style.opacity='';
  subEl.style.opacity='';
  void titleEl.offsetWidth; // reflow to reset animation
}

render();
</script>
</body>
</html>
